#!/bin/bash -efu
# vim:set foldmethod=marker:

OCDEV_VARDIR=${OCDEV_VARDIR:=$HOME/.ocdev}

PROGNAME=$(basename "$0")

usage() {
    echo "usage: $PROGNAME <command>"
    echo
    echo "Available commands:"
    echo "  show-toplevel  Show the absolute path of the top-level directory"
    echo "  show-bindir    Show the absolute path of the directory with OpenShift binaries"
    echo "  env            Show adjusted environment variables"
    echo "  build-all      Build openshift, oc, and dockerregistry"
    echo "  destroy        Remove generated config files, etcd data, volumes, etc"
    echo
    echo "OpenShift:"
    echo "  build          Build openshift and oc binaries"
    echo "  start          Start the all-in-one OpenShift server in the foreground"
    echo
    echo "Commands for the registry:"
    echo "  build-registry-image  Build the ocdev-registry:latest Docker image"
    echo "  build-registry        Build the dockerregistry binary"
    echo "  start-registry        Create Service and DeploymentConfig for the registry"
    echo "  rollout-registry      Redeploy the registry"
    echo "  update-registry       Rebuild and redeploy the registry"
    echo
    echo "Usage examples:"
    echo "  ocdev build-all"
    echo "  ocdev start --loglevel=4"
    echo "  ocdev start-registry"
    echo
    echo "  ocdev update-registry"
}

fatal() {
    echo "$PROGNAME: $*" >&2
    exit 1
}

cd_toplevel() {
    local toplevel
    toplevel=$(git rev-parse --show-toplevel)
    cd "$toplevel"
}

# {{{ ocdev

ocdev-show-toplevel() {
    pwd
}

ocdev-show-bindir() {
    echo "$PWD/_output/local/bin/$(go env GOHOSTOS)/$(go env GOHOSTARCH)"
}

ocdev-env() {
    local bindir=$(ocdev-show-bindir) oc=$(which oc 2>/dev/null)
    if [ "$oc" != "$bindir/oc" ]; then
        PATH="$bindir:$PATH"
    fi

    printf "export PATH=%q\n" "$PATH"
}

ocdev-build-all() {
    ocdev-build
    ocdev-build-pod-image
    ocdev-build-registry
}

ocdev-build-pod-image() {
    ./hack/build-go.sh images/pod
    cp "$(ocdev-show-bindir)/pod" ./images/pod/bin/pod
    docker build -t openshift/origin-pod:latest ./images/pod
    rm ./images/pod/bin/pod
}

ocdev-destroy() {
    mount | grep -F "$OCDEV_VARDIR/openshift.local.volumes" | cut -d' ' -f3 | xargs -r sudo umount
    sudo rm -rf "$OCDEV_VARDIR"
}

# }}}

# {{{ openshift

ocdev-build() {
    ./hack/build-go.sh cmd/openshift cmd/oc
}

ocdev-start() {
    eval "$(ocdev-env)"

    local openshift
    if ! openshift=$(which openshift); then
        fatal "start: failed to find openshift binary"
    fi

    local configdir="$OCDEV_VARDIR/openshift.local.config"
    local etcddir="$OCDEV_VARDIR/openshift.local.etcd"
    local volumedir="$OCDEV_VARDIR/openshift.local.volumes"

    "$openshift" start --write-config="$configdir" \
        --images='openshift/origin-${component}:latest' \
        --etcd-dir="$etcddir" \
        --volume-dir="$volumedir"
    sudo chmod +r "$configdir/master/admin.kubeconfig"
    cp "$configdir/master/admin.kubeconfig" "$HOME/.kube/config"

    sudo "$openshift" start \
        --master-config="$configdir/master/master-config.yaml" \
        --node-config="$configdir/node-localhost/node-config.yaml" \
        "$@"
}

# }}}

# {{{ registry

ocdev-build-registry-image() {
    docker build -t ocdev-registry - <<END
FROM fedora
USER 1001
EXPOSE 5000
ENV REGISTRY_CONFIGURATION_PATH=/openshift/images/dockerregistry/config.yml
VOLUME /registry
VOLUME /openshift/bin
CMD /openshift/bin/dockerregistry
END
}

ocdev-build-registry() {
    ./hack/build-go.sh cmd/dockerregistry
    ocdev-build-registry-image
}

ocdev-start-registry() {
    local toplevel="$(ocdev-show-toplevel)" bindir="$(ocdev-show-bindir)"
    local imagesdir="$toplevel/images"
    oadm registry -o json |
        jq --arg bindir "$bindir" --arg imagesdir "$imagesdir" '
            path(.items[] | select(.kind == "Service" and .metadata.name == "docker-registry")) as $svc |
            setpath($svc + ["spec", "clusterIP"]; "172.30.1.1") |

            path(.items[] | select(.kind == "DeploymentConfig" and .metadata.name == "docker-registry")) as $dc |
            ($dc + ["spec", "template", "spec", "volumes"]) as $volumes |
            setpath($volumes; getpath($volumes) + [{
                "name": "openshift-bin",
                "hostPath": {
                    "path": $bindir
                }
            }, {
                "name": "openshift-images",
                "hostPath": {
                    "path": $imagesdir
                }
            }]) |

            path(.items[] | select(.kind == "DeploymentConfig" and .metadata.name == "docker-registry") | .spec.template.spec.containers[] | select(.name == "registry")) as $container |
            setpath($container + ["image"]; "ocdev-registry:latest") |
            setpath($container + ["imagePullPolicy"]; "Never") |
            setpath($container + ["volumeMounts"]; getpath($container + ["volumeMounts"]) + [{
                "name": "openshift-bin",
                "mountPath": "/openshift/bin"
            }, {
                "name": "openshift-images",
                "mountPath": "/openshift/images"
            }])
        ' |
        oc create -f -
    oadm policy add-scc-to-user hostaccess -z registry
}

ocdev-rollout-registry() {
    oc rollout latest dc/docker-registry || true
    oc rollout status dc/docker-registry
}

ocdev-update-registry() {
    ocdev-registry-build
    ocdev-registry-rollout
}

# }}}

cd_toplevel
[ $# -ge 1 ] || { usage >&2; exit 1; }
if declare -f "ocdev-$1" >/dev/null || test -x "ocdev-$1"; then
    "ocdev-$@"
else
    usage >&2
    exit 1
fi
